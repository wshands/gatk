package org.broadinstitute.hellbender.tools.walkers.sv;

import htsjdk.samtools.SAMSequenceDictionary;
import htsjdk.samtools.util.IntervalTree;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.vcf.VCFHeader;
import htsjdk.variant.vcf.VCFHeaderLine;
import org.broadinstitute.barclay.argparser.Argument;
import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;
import org.broadinstitute.barclay.argparser.ExperimentalFeature;
import org.broadinstitute.barclay.help.DocumentedFeature;
import org.broadinstitute.hellbender.cmdline.StandardArgumentDefinitions;
import org.broadinstitute.hellbender.cmdline.programgroups.StructuralVariantDiscoveryProgramGroup;
import org.broadinstitute.hellbender.engine.*;
import org.broadinstitute.hellbender.exceptions.UserException;
import org.broadinstitute.hellbender.tools.sv.SVCallRecord;
import org.broadinstitute.hellbender.tools.sv.SVCallRecordUtils;
import org.broadinstitute.hellbender.tools.sv.cluster.SVClusterEngine;
import org.broadinstitute.hellbender.utils.SimpleInterval;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Select a subset of records from a structural variant (SV) VCF generated by {@link SVPreprocessRecords}. This tool is distinct from
 * {@link org.broadinstitute.hellbender.tools.walkers.variantutils.SelectVariants} in that intervals specified with
 * -L and -XL behave differently. Rather than retrieving only records based on their positions as indicated by the
 * index file, all variants are retrieved and then filtered based on the following criteria:
 * <ul>
 *     <li>
 *         minimum overlap fraction with the intervals
 *     </li>
 *     <li>
 *         both endpoints must be contained in the intervals (optional)
 *     </li>
 *     <li>
 *         minimum variant length (all interchromosomal records are retained)
 *     </li>
 * </ul>
 *
 * Output can be restricted to or exclusive of variants only supported by depth-based algorithms ("depth-only").
 *
 * <h3>Inputs</h3>
 *
 * <ul>
 *     <li>
 *         A VCF containing only structural variant records
 *     </li>
 * </ul>
 *
 * <h3>Output</h3>
 *
 * <ul>
 *     <li>
 *         The input VCF with filtered records removed
 *     </li>
 * </ul>
 *
 * <h3>Usage example</h3>
 *
 * <pre>
 *     gatk SVSelectVariants \
 *       -I intervals.intervals_list \
 *       -V variants.vcf.gz \
 *       -O filtered.vcf.gz
 * </pre>
 *
 * @author Mark Walker &lt;markw@broadinstitute.org&gt;
 */

@CommandLineProgramProperties(
        summary = "Select a subset of SV records generated by MergeSVCalls",
        oneLineSummary = "Select a subset of SV records generated by MergeSVCalls",
        programGroup = StructuralVariantDiscoveryProgramGroup.class
)
@ExperimentalFeature
@DocumentedFeature
public final class SVSelectVariants extends VariantWalker {
    public static final String MIN_SIZE_LONG_NAME = "min-size";
    public static final String MIN_OVERLAP_FRACTION_LONG_NAME = "min-overlap-fraction";
    public static final String REQUIRE_BREAKEND_OVERLAP_LONG_NAME = "require-breakend-overlap";
    public static final String FILTER_DEPTH_ONLY_LONG_NAME = "depth-only";
    public static final String FILTER_NON_DEPTH_ONLY_LONG_NAME = "non-depth-only";

    @Argument(
            doc = "Output VCF",
            fullName = StandardArgumentDefinitions.OUTPUT_LONG_NAME,
            shortName = StandardArgumentDefinitions.OUTPUT_SHORT_NAME
    )
    private GATKPath outputFile;

    /**
     * Variant length is defined differently depending on variant type. For insertions, the SVLEN info field is used.
     * For all other variants, it is the distance between the start and end positions. All interchromosomal variants
     * (i.e. different start and end contigs) are retained.
     */
    @Argument(
            doc = "Minimum variant size",
            fullName = MIN_SIZE_LONG_NAME,
            minValue = 0,
            optional = true
    )
    private int minEventSize = 50;

    @Argument(
            doc = "Filter out a variant if its overlap fraction with the included intervals is below this threshold",
            fullName = MIN_OVERLAP_FRACTION_LONG_NAME,
            minValue = 0.,
            maxValue = 1.,
            optional = true
    )
    private double minOverlapFraction = 0.5;

    @Argument(
            doc = "Filter out a variant if any end of its breakpoint is not in the included intervals.",
            fullName = REQUIRE_BREAKEND_OVERLAP_LONG_NAME,
            optional = true
    )
    private boolean requireBreakendOverlap = false;

    /**
     * Use to only include variants whose ALGORITHMS info field lists solely "depth".
     */
    @Argument(
            doc = "Only include CNVs called only by depth-based algorithms.",
            fullName = FILTER_DEPTH_ONLY_LONG_NAME,
            optional = true
    )
    private boolean depthOnly = false;

    /**
     * Use to only include variants whose ALGORITHMS info field does not list solely "depth".
     */
    @Argument(
            doc = "Filter CNVs called only by depth-based algorithms.",
            fullName = FILTER_NON_DEPTH_ONLY_LONG_NAME,
            optional = true
    )
    private boolean nonDepthOnly = false;

    private SAMSequenceDictionary dictionary;
    private final Map<String,IntervalTree<Object>> includedIntervalsTreeMap = new HashMap<>();
    private VariantContextWriter writer;

    @Override
    public boolean ignoresIntervalsForTraversal() {
        return true;
    }

    @Override
    public void onTraversalStart() {
        if (depthOnly && nonDepthOnly) {
            throw new UserException.BadInput("Cannot use both --" + FILTER_DEPTH_ONLY_LONG_NAME + " and --" + FILTER_NON_DEPTH_ONLY_LONG_NAME);
        }
        dictionary = getHeaderForVariants().getSequenceDictionary();
        if (dictionary == null) {
            throw new UserException.MissingReference("Sequence dictionary not found in header");
        }
        loadIntervalTree();
        writer = createVCFWriter(outputFile);
        writeVCFHeader();
    }

    @Override
    public Object onTraversalSuccess() {
        writer.close();
        return null;
    }

    private void loadIntervalTree() {
        final List<SimpleInterval> intervals = getRequestedIntervals();
        if (intervals == null) {
            throw new UserException.MissingReference("Reference dictionary is required");
        }
        for (final SimpleInterval interval : intervals) {
            includedIntervalsTreeMap.putIfAbsent(interval.getContig(), new IntervalTree<>());
            includedIntervalsTreeMap.get(interval.getContig()).put(interval.getStart(), interval.getEnd(), null);
        }
    }

    @Override
    public void apply(final VariantContext variant, final ReadsContext readsContext,
                      final ReferenceContext referenceContext, final FeatureContext featureContext) {
        final SVCallRecord record = SVCallRecordUtils.create(variant);
        final boolean variantDepthOnly = SVClusterEngine.isDepthOnlyCall(record);
        if (depthOnly && !variantDepthOnly) {
            return;
        }
        if (nonDepthOnly && variantDepthOnly) {
            return;
        }
        if (!SVCallRecordUtils.isValidSize(record, minEventSize)) {
            return;
        }
        if (!SVCallRecordUtils.intervalIsIncluded(record, includedIntervalsTreeMap, minOverlapFraction, requireBreakendOverlap)) {
            return;
        }
        writer.add(variant);
    }

    private void writeVCFHeader() {
        final VCFHeader inputHeader = getHeaderForVariants();
        final VCFHeader header = new VCFHeader(getDefaultToolVCFHeaderLines(), inputHeader.getSampleNamesInOrder());
        for (final VCFHeaderLine line : inputHeader.getMetaDataInInputOrder()) {
            header.addMetaDataLine(line);
        }
        writer.writeHeader(header);
    }
}
